\documentclass{article}
\begin{document}
\subsection{COINES C examples}
\subsubsection{Establishing communication}
The following code snippet shows how to set up a connection with the board.
\begin{lstlisting}[language=c]
	#include <stdio.h>
	#include <stdlib.h>
	
	#include "coines.h"
	
	int main(void)
	{
		int8_t error_code;
		enum coines_comm_intf comm_intf = COINES_COMM_INTF_USB;

		error_code = coines_open_comm_intf(comm_intf, NULL);
		if (error_code == COINES_SUCCESS)
		{
			printf("\nSuccessfully connected to board!\n");
		}
		else
		{
			printf("\nUnable to connect with board!\n");
			exit(error_code);
		}
	
		coines_close_comm_intf(comm_intf, NULL);
	
		return 0;
	}

\end{lstlisting}
The APIs below can be used for board interface.
\begin{itemize}
	\item \texttt{coines\_open\_comm\_intf}
	\item \texttt{coines\_close\_comm\_intf}
\end{itemize}

\subsubsection{Getting board info}
The following code snippet shows how to get board information.
\begin{lstlisting}[language=c]
	#include <stdio.h>
	#include <stdlib.h>
	
	#include "coines.h"
	
	int main(void)
	{
		int8_t error_code;
		struct coines_board_info board_info;
		enum coines_comm_intf comm_intf = COINES_COMM_INTF_USB;
	
		error_code = coines_open_comm_intf(comm_intf, NULL);
		if (error_code < COINES_SUCCESS)
		{
			printf("\nUnable to connect with board!\n");
			exit(error_code);
		}
	
		error_code = coines_get_board_info(&board_info);
		if (error_code == COINES_SUCCESS)
		{
			printf("\nBoard Info:");
			printf("\n\tboard_info.board:0x%02X", board_info.board);
			printf("\n\tboard_info.hardware_id:0x%02X", board_info.hardware_id);
			printf("\n\tboard_info.shuttle_id:0x%02X", board_info.shuttle_id);
			printf("\n\tboard_info.software_id:0x%02X", board_info.software_id);
		}
	
		coines_close_comm_intf(comm_intf, NULL);
	
		return 0;
	}
	
\end{lstlisting}

\subsubsection{I2C config and read}
This basic program shows how to configure and perform I2C read.
\newline Sensor: BMI270
\begin{lstlisting}[language=c]
	#include <stdio.h>
	#include <stdlib.h>
	
	#include "coines.h"
	
	#define BMI2_I2C_PRIM_ADDR  0x68
	
	int main(void)
	{
		int8_t error_code;
		uint8_t chip_id;
		uint8_t reg_addr = 0x0;
		enum coines_comm_intf comm_intf = COINES_COMM_INTF_USB;
	
		error_code = coines_open_comm_intf(comm_intf, NULL);
		if (error_code == COINES_SUCCESS)
		{
			printf("\nSuccessfully connected to board!\n");
		}
		else
		{
			printf("\nUnable to connect with board!\n");
			exit(error_code);
		}
	
		/* Power up the board */
		(void)coines_set_shuttleboard_vdd_vddio_config(3300, 3300);
		coines_delay_usec(200);
	
		/* SDO to Ground */
		coines_set_pin_config(COINES_SHUTTLE_PIN_22, COINES_PIN_DIRECTION_OUT, COINES_PIN_VALUE_LOW);
	
		/* Make CSB pin HIGH */
		coines_set_pin_config(COINES_SHUTTLE_PIN_21, COINES_PIN_DIRECTION_OUT, COINES_PIN_VALUE_HIGH);
		coines_delay_msec(100);
	
		/* SDO pin is made low */
		coines_set_pin_config(COINES_SHUTTLE_PIN_SDO, COINES_PIN_DIRECTION_OUT, COINES_PIN_VALUE_LOW);
	
		/* I2C config */
		coines_config_i2c_bus(COINES_I2C_BUS_0, COINES_I2C_STANDARD_MODE);
	
		/* I2C read */
		(void)coines_read_i2c(COINES_I2C_BUS_0, BMI2_I2C_PRIM_ADDR, reg_addr, &chip_id, 1);
	
		printf("I2C read: Sensor chip ID - 0x%x\n", chip_id);
	
		(void)coines_set_shuttleboard_vdd_vddio_config(0, 0);
		coines_delay_msec(100);
	
		/* Coines interface reset */
		coines_soft_reset();
		coines_delay_msec(100);
	
		coines_close_comm_intf(comm_intf, NULL);
	
		return 0;
	}
\end{lstlisting}
The user shall pass GPIO pin numbers, read register address and I2C device address for sensors based on the selected sensor shuttle board. I2C communication require the proper setting of VDD and VDDIO using \texttt{coines\_set\_shuttleboard\_vdd\_vddio\_config}.
The APIs below can be used for I2C configure/read/write.
\begin{itemize}
	\item \texttt{coines\_config\_i2c\_bus}
	\item \texttt{coines\_read\_i2c}
	\item \texttt{coines\_write\_i2c}
\end{itemize}

\subsubsection{SPI config and read}
This basic program shows how to configure and perform SPI read.
\newline Sensor: BMI270
\begin{lstlisting}[language=c]
	#include <stdio.h>
	#include <stdlib.h>
	
	#include "coines.h"
	
	#define BMI2_SPI_RD_MASK  0x80
	
	int main(void)
	{
		int8_t error_code;
		uint8_t chip_id[2], dummy_byte;
	
		/* An extra dummy byte is read during SPI read */
		uint8_t dummy_byte_len = 1;
		uint8_t reg_addr = 0x0;
		enum coines_comm_intf comm_intf = COINES_COMM_INTF_USB;
	
		error_code = coines_open_comm_intf(comm_intf, NULL);
		if (error_code == COINES_SUCCESS)
		{
			printf("\nSuccessfully connected to board!\n");
		}
		else
		{
			printf("\nUnable to connect with board!\n");
			exit(error_code);
		}
	
		/* Power up the board */
		coines_set_shuttleboard_vdd_vddio_config(3300, 3300);
		coines_delay_msec(200);
	
		/* SPI config */
		(void)coines_config_spi_bus(COINES_SPI_BUS_0, COINES_SPI_SPEED_5_MHZ, COINES_SPI_MODE3);
	
		/* Pin config */
		coines_set_pin_config(COINES_SHUTTLE_PIN_21, COINES_PIN_DIRECTION_OUT, COINES_PIN_VALUE_HIGH);
	
		/* Mask read register address for SPI */
		reg_addr = (reg_addr | BMI2_SPI_RD_MASK);
	
		/* Dummy read for SPI init*/
		(void)coines_read_spi(COINES_SPI_BUS_0, COINES_MINI_SHUTTLE_PIN_2_1, reg_addr, &dummy_byte, 1);
		coines_delay_usec(450);
	
		/* SPI read */
		(void)coines_read_spi(COINES_SPI_BUS_0, COINES_MINI_SHUTTLE_PIN_2_1, reg_addr, chip_id, 1 + dummy_byte_len);
		coines_delay_usec(450);
	
		printf("SPI read: Sensor chip ID - 0x%x\n", chip_id[dummy_byte_len]);
	
		(void)coines_set_shuttleboard_vdd_vddio_config(0, 0);
		coines_delay_msec(100);
	
		/* Coines interface reset */
		coines_soft_reset();
		coines_delay_msec(100);
	
		coines_close_comm_intf(comm_intf, NULL);
	
		return 0;
	}
\end{lstlisting}
The user shall pass GPIO pin numbers, read register address and SPI CS pins for sensors based on the selected sensor shuttle board. SPI communication require the proper setting of VDD and VDDIO using \texttt{coines\_set\_shuttleboard\_vdd\_vddio\_config}.
The APIs below can be used for SPI configure/read/write.
\begin{itemize}
	\item \texttt{coines\_config\_spi\_bus}
	\item \texttt{coines\_read\_spi}
	\item \texttt{coines\_write\_spi}
\end{itemize}
\subsubsection{Led and button control}
The example program below is to control LEDs and buttons on the board.
\newline Target: MCU
\begin{lstlisting}[language=c]
	#include <stdio.h>
	#include <stdbool.h>
	#include "coines.h"
	
	/* Callback for button 1 interrupt */
	static void button1CB(uint32_t param1, uint32_t param2);
	
	/*Callback for button 1 event */
	void button1CB(uint32_t param1, uint32_t param2)
	{
		(void)param1;
		(void)param2;
	
		coines_set_led(COINES_LED_RED, COINES_LED_STATE_ON);
		coines_set_led(COINES_LED_GREEN, COINES_LED_STATE_OFF);
		coines_set_led(COINES_LED_BLUE, COINES_LED_STATE_ON);
	}
	
	int main(void)
	{
		coines_open_comm_intf(COINES_COMM_INTF_USB, NULL);
	
		coines_set_pin_config(COINES_APP30_BUTTON_1, COINES_PIN_DIRECTION_IN, COINES_PIN_VALUE_HIGH);
		coines_attach_interrupt(COINES_APP30_BUTTON_1, button1CB, COINES_PIN_INTERRUPT_FALLING_EDGE);
	
		coines_close_comm_intf(COINES_COMM_INTF_USB, NULL);
	
		return 0;
	}
\end{lstlisting}

\subsubsection{File listing in External memory}
To list the files in the external memory, below snippet can be used.
\newline Target: MCU
\begin{lstlisting}[language=c]
	#include <stdio.h>
	#include "coines.h"
	
	int main(void)
	{
		coines_open_comm_intf(COINES_COMM_INTF_USB, NULL);
		DIR *directory;
		struct dirent *dir;
		directory = opendir(".");
		if (directory)
		{
			while ((dir = readdir(directory)) != NULL)
			{
				printf("%s\n", dir->d_name);
			}
	
			closedir(directory);
		}
	
		coines_close_comm_intf(COINES_COMM_INTF_USB, NULL);
	
		return 0;
	}
\end{lstlisting}
\subsubsection{Temperature measurement}
This simple program demonstrates how to measure temperature of the board.
\newline Target: MCU
\begin{lstlisting}[language=c]
	#include <stdio.h>
	#include <stdlib.h>

	#include "coines.h"

	int main(void)
	{
		int8_t error_code;
		float temp_data = 0;
		enum coines_comm_intf comm_intf = COINES_COMM_INTF_USB;

		error_code = coines_open_comm_intf(comm_intf, NULL);
		if (error_code == COINES_SUCCESS)
		{
			printf("\nSuccessfully connected to board!\n");
		}
		else
		{
			printf("\nUnable to connect with board!\n");
			exit(error_code);
		}

		/* Power up the board */
		coines_set_shuttleboard_vdd_vddio_config(1800, 1800);
		coines_delay_msec(200);

		/* Read temperature data */
		coines_read_temp_data(&temp_data);
		printf("\nTemperature data = %f in degC", temp_data);

		coines_set_shuttleboard_vdd_vddio_config(0, 0);
		coines_delay_msec(100);

		coines_close_comm_intf(comm_intf, NULL);

		return 0;
	}
\end{lstlisting}

\subsubsection{Battery level measurement}
This simple program demonstrates how to measure battery level when a battery is connected to the board.
\newline Target: MCU
\begin{lstlisting}[language=c]
	#include <stdio.h>
	#include <stdlib.h>
	
	#include "coines.h"
	
	int main(void)
	{
		int8_t error_code;
		uint8_t batt_status_percentage = 0;
		uint16_t batt_status_in_milli_volts = 0;
		enum coines_comm_intf comm_intf = COINES_COMM_INTF_BLE;
	
		error_code = coines_open_comm_intf(comm_intf, NULL);
		if (error_code == COINES_SUCCESS)
		{
			printf("\nSuccessfully connected to board!\n");
		}
		else
		{
			printf("\nUnable to connect with board!\n");
			exit(error_code);
		}
	
		/* Read battery level */
		coines_read_bat_status(&batt_status_in_milli_volts, &batt_status_percentage);
		fprintf(bt_w, "Battery level in percentage = %d %% \r\n", batt_status_percentage);
		fprintf(bt_w, "Battery level in millivolts = %d mV \r\n", batt_status_in_milli_volts);
	
		coines_close_comm_intf(comm_intf, NULL);
	
		return 0;
	}
\end{lstlisting}

\subsubsection{Configure BLE communication}\label{bleComConfig}
This example shows how to configure BLE connection.
\newline Target: PC
\begin{lstlisting}[language=c]
	#include <stdio.h>
	#include <string.h>
	#include <stdlib.h>
	
	#include "coines.h"
	
	/*! Macros to hold the BLE peripheral name and address to be connected */
	/*! Please change the name and address with BLE name of the Application board under test */
	#define BLE_NAME  "APP Board 3.0(B6-E5)"
	#define BLE_ADDR  "dd:fc:ab:af:b6:e5"
	
	/*! Variable to hold the communication interface type */
	const enum coines_comm_intf comm_intf = COINES_COMM_INTF_BLE;
	
	int main(void)
	{
		struct ble_peripheral_info ble_config = { BLE_ADDR, "" };
		struct ble_peripheral_info ble_info[40];
		uint8_t peripheral_count, i;
		int8_t result;
	
		/* Get the BLE peripheral list */
		result = coines_scan_ble_devices(ble_info, &peripheral_count, 7000);
		if (result != COINES_SUCCESS)
		{
			const char *err_str = get_coines_error_str(result);
			printf("\n%s", err_str);
			exit(result);
		}
	
		/* Print the BLE peripheral list */
		printf("\nBLE devices found:");
		for (i = 0; i < peripheral_count; i++)
		{
			printf("\n[%d] %s [%s]", i, ble_info[i].ble_identifier, ble_info[i].ble_address);
		}
	
		/* Open BLE connection */
		result = coines_open_comm_intf(comm_intf, &ble_config);
		if (result == COINES_SUCCESS)
		{
			printf("\nSuccessfully connected to board!\n");
		}
		else
		{
			printf("\nUnable to connect with board!\n");
			exit(result);
		}
	
		/* Close BLE connection */
		coines_soft_reset();
		coines_delay_msec(100);
	
		coines_close_comm_intf(comm_intf, NULL);
	
		return 0;
	}	

\end{lstlisting}
The user shall modify BLE settings like address and name before executing this example.
\subsubsection{Configure Serial communication}\label{serialComConfig}
This example shows how to configure Serial COM connection.
\newline Target: PC
\begin{lstlisting}[language=c]
	#include <stdio.h>
	#include <string.h>
	#include <stdlib.h>
	
	#include "coines.h"
	
	#define ROBERT_BOSCH_USB_VID   (0x108C)
	#define ARDUINO_USB_VID        (0x2341)
	#define BST_APP30_CDC_USB_PID  (0xAB3C)
	#define BST_APP20_CDC_USB_PID  (0xAB2C)
	#define ARDUINO_NICLA_USB_PID  (0x0060)
	
	/*! Variable to hold the communication interface type */
	const enum coines_comm_intf comm_intf = COINES_COMM_INTF_USB;
	
	int main(void)
	{
		int16_t result;
		struct coines_serial_com_config scom_config;
	
		scom_config.baud_rate = 38400;
		scom_config.vendor_id = ROBERT_BOSCH_USB_VID;
		scom_config.product_id = BST_APP30_CDC_USB_PID;
		scom_config.com_port_name = "COM4";
		scom_config.rx_buffer_size = 2048;
	
		/* Open serial connection */
		result = coines_open_comm_intf(comm_intf, &scom_config);
		if (result == COINES_SUCCESS)
		{
			printf("\nSuccessfully connected to board!\n");
		}
		else
		{
			printf("\nUnable to connect with board!\n");
			exit(result);
		}
	
		/* Close serial connection */
		coines_soft_reset();
		coines_delay_msec(100);
	
		coines_close_comm_intf(comm_intf, NULL);
	
		return 0;
	}
	
\end{lstlisting}
The user shall modify Serial COM settings like vendor ID, product ID and COM port name before executing this example.

\end{document}